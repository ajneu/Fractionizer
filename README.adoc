= Fractionizer
:source-highlighter: prettify
                     // coderay highlightjs prettify pygments
:coderay-linenums-mode: inline
:toc:
:imagesdir: images

C++ class to convert floating point values to fractions, by using continued fractions.

How this works is best shown by an example:

image::example_frac.svg[Continued Fraction]

The continued fraction has only integer whole numbers, that can be expressed in a vector:

image::vector_example.svg[]

As a formula-equation, the generation of continued fractions can be expressed as:

image::equation.svg[Equation]
(with `frac(x)` as shown https://en.wikipedia.org/wiki/Fractional_part[here])

As can be seen from the formula-equation above, given a number image:x_i.svg[]: +
If this number is not yet an integer (whole number)

* we truncate the number, so that we get an integer (whole number): image:whole.svg[] +
and then
* calculate the reciprocal of the fractional part image:reciprocal.svg[], to get the next number image:x_i1.svg[] +
and recursion...

We end, when we get a image:x_j.svg[] that is a whole number.

This gives as a vector of whole numbers:

image::vector.svg[]

representing a continued fraction:

image::cont_frac.svg[]

So much for idealized math. 

But given a computers floating point with limited precision (`float`, `double`, `long double`), the program calculates the resulting value of the continued fraction, at each new image:w_i.svg[] and compares it to image:x_i.svg[]

image::vectors.svg[]

The program stops, when we are close enough to image:x_i.svg[].
